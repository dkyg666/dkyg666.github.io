import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,e as n,o as c}from"./app-BAGG9h-A.js";const i={};function d(l,e){return c(),s("div",null,e[0]||(e[0]=[n(`<h1 id="容器访问控制" tabindex="-1"><a class="header-anchor" href="#容器访问控制"><span>容器访问控制</span></a></h1><p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p><h2 id="容器访问外部网络" tabindex="-1"><a class="header-anchor" href="#容器访问外部网络"><span>容器访问外部网络</span></a></h2><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token variable">$sysctl</span> net.ipv4.ip_forward
net.ipv4.ip_forward <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果为 0，说明没有开启转发，则需要手动打开。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token variable">$sysctl</span> <span class="token parameter variable">-w</span> <span class="token assign-left variable">net.ipv4.ip_forward</span><span class="token operator">=</span><span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p><h2 id="容器之间访问" tabindex="-1"><a class="header-anchor" href="#容器之间访问"><span>容器之间访问</span></a></h2><p>容器之间相互访问，需要两方面的支持。</p><ul><li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li><li>本地系统的防火墙软件 -- <code>iptables</code> 是否允许通过。</li></ul><h3 id="访问所有端口" tabindex="-1"><a class="header-anchor" href="#访问所有端口"><span>访问所有端口</span></a></h3><p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p><p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>{&quot;icc&quot;: false}</code> 来禁止它。</p><h3 id="访问指定端口" tabindex="-1"><a class="header-anchor" href="#访问指定端口"><span>访问指定端口</span></a></h3><p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p><p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p><p>此时，系统中的 <code>iptables</code> 规则可能是类似</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-nL</span>
<span class="token punctuation">..</span>.
Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DROP       all  --  <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0
<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后，启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p><p>当添加了 <code>--link=CONTAINER_NAME:ALIAS</code> 选项后，添加了 <code>iptables</code> 规则。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-nL</span>
<span class="token punctuation">..</span>.
Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
ACCEPT     tcp  --  <span class="token number">172.17</span>.0.2           <span class="token number">172.17</span>.0.3           tcp spt:80
ACCEPT     tcp  --  <span class="token number">172.17</span>.0.3           <span class="token number">172.17</span>.0.2           tcp dpt:80
DROP       all  --  <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 <code>--name</code> 参数指定的名字。主机名则不会被识别。</p>`,23)]))}const p=a(i,[["render",d],["__file","access_control.html.vue"]]),r=JSON.parse('{"path":"/index/Docker/advanced_network/access_control.html","title":"容器访问控制","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"容器访问外部网络","slug":"容器访问外部网络","link":"#容器访问外部网络","children":[]},{"level":2,"title":"容器之间访问","slug":"容器之间访问","link":"#容器之间访问","children":[{"level":3,"title":"访问所有端口","slug":"访问所有端口","link":"#访问所有端口","children":[]},{"level":3,"title":"访问指定端口","slug":"访问指定端口","link":"#访问指定端口","children":[]}]}],"git":{"createdTime":1731129855000,"updatedTime":1731129855000,"contributors":[{"name":"dkyg666","email":"43946866+dkyg666@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":2.04,"words":613},"filePathRelative":"index/Docker/advanced_network/access_control.md","localizedDate":"2024年11月9日","excerpt":"\\n<p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>\\n<h2>容器访问外部网络</h2>\\n<p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>\\n<div class=\\"language-bash\\" data-ext=\\"sh\\" data-title=\\"sh\\"><pre class=\\"language-bash\\"><code><span class=\\"token variable\\">$sysctl</span> net.ipv4.ip_forward\\nnet.ipv4.ip_forward <span class=\\"token operator\\">=</span> <span class=\\"token number\\">1</span>\\n</code></pre></div>"}');export{p as comp,r as data};
