import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,b as n,d as s,a as t,e as i,o as c,r as p}from"./app-BAGG9h-A.js";const l={},r={href:"https://github.com/moby/buildkit",target:"_blank",rel:"noopener noreferrer"},u={href:"https://github.com/docker-practice/docker-hub-buildx",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md",target:"_blank",rel:"noopener noreferrer"};function k(b,e){const a=p("ExternalLinkIcon");return c(),d("div",null,[e[7]||(e[7]=n("h1",{id:"使用-buildkit-构建镜像",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#使用-buildkit-构建镜像"},[n("span",null,[s("使用 "),n("code",null,"BuildKit"),s(" 构建镜像")])])],-1)),n("p",null,[e[1]||(e[1]=n("strong",null,"BuildKit",-1)),e[2]||(e[2]=s(" 是下一代的镜像构建组件，在 ")),n("a",r,[e[0]||(e[0]=s("https://github.com/moby/buildkit")),t(a)]),e[3]||(e[3]=s(" 开源。"))]),e[8]||(e[8]=n("p",null,[n("strong",null,"注意：如果您的镜像构建使用的是云服务商提供的镜像构建服务（腾讯云容器服务、阿里云容器服务等），由于上述服务提供商的 Docker 版本低于 18.09，BuildKit 无法使用，将造成镜像构建失败。建议使用 BuildKit 构建镜像时使用一个新的 Dockerfile 文件（例如 Dockerfile.buildkit）")],-1)),n("p",null,[e[5]||(e[5]=s("目前，Docker Hub 自动构建已经支持 buildkit，具体请参考 ")),n("a",u,[e[4]||(e[4]=s("https://github.com/docker-practice/docker-hub-buildx")),t(a)])]),e[9]||(e[9]=i(`<h2 id="dockerfile-新增指令详解" tabindex="-1"><a class="header-anchor" href="#dockerfile-新增指令详解"><span><code>Dockerfile</code> 新增指令详解</span></a></h2><p>启用 <code>BuildKit</code> 之后，我们可以使用下面几个新的 <code>Dockerfile</code> 指令来加快镜像构建。</p><h3 id="run-mount-type-cache" tabindex="-1"><a class="header-anchor" href="#run-mount-type-cache"><span><code>RUN --mount=type=cache</code></span></a></h3><p>目前，几乎所有的程序都会使用依赖管理工具，例如 <code>Go</code> 中的 <code>go mod</code>、<code>Node.js</code> 中的 <code>npm</code> 等等，当我们构建一个镜像时，往往会重复的从互联网中获取依赖包，难以缓存，大大降低了镜像的构建效率。</p><p>例如一个前端工程需要用到 <code>npm</code>：</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> node:alpine <span class="token keyword">as</span> builder</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">COPY</span> package.json /app/</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm i --registry=https://registry.npm.taobao.org <span class="token operator">\\</span>
        &amp;&amp; rm -rf ~/.npm</span>

<span class="token instruction"><span class="token keyword">COPY</span> src /app/src</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm run build</span>

<span class="token instruction"><span class="token keyword">FROM</span> nginx:alpine</span>

<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">builder</span></span> /app/dist /app/dist</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用多阶段构建，构建的镜像中只包含了目标文件夹 <code>dist</code>，但仍然存在一些问题，当 <code>package.json</code> 文件变动时，<code>RUN npm i &amp;&amp; rm -rf ~/.npm</code> 这一层会重新执行，变更多次后，生成了大量的中间层镜像。</p><p>为解决这个问题，进一步的我们可以设想一个类似 <strong>数据卷</strong> 的功能，在镜像构建时把 <code>node_modules</code> 文件夹挂载上去，在构建完成后，这个 <code>node_modules</code> 文件夹会自动卸载，实际的镜像中并不包含 <code>node_modules</code> 这个文件夹，这样我们就省去了每次获取依赖的时间，大大增加了镜像构建效率，同时也避免了生成了大量的中间层镜像。</p><p><code>BuildKit</code> 提供了 <code>RUN --mount=type=cache</code> 指令，可以实现上边的设想。</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># syntax = docker/dockerfile:experimental</span>
<span class="token instruction"><span class="token keyword">FROM</span> node:alpine <span class="token keyword">as</span> builder</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">COPY</span> package.json /app/</span>

<span class="token instruction"><span class="token keyword">RUN</span> <span class="token options"><span class="token property">--mount</span><span class="token punctuation">=</span><span class="token string">type=cache,target=/app/node_modules,id=my_app_npm_module,sharing=locked</span> <span class="token operator">\\</span>
    <span class="token property">--mount</span><span class="token punctuation">=</span><span class="token string">type=cache,target=/root/.npm,id=npm_cache</span></span> <span class="token operator">\\</span>
        npm i --registry=https://registry.npm.taobao.org</span>

<span class="token instruction"><span class="token keyword">COPY</span> src /app/src</span>

<span class="token instruction"><span class="token keyword">RUN</span> <span class="token options"><span class="token property">--mount</span><span class="token punctuation">=</span><span class="token string">type=cache,target=/app/node_modules,id=my_app_npm_module,sharing=locked</span></span> <span class="token operator">\\</span>
<span class="token comment"># --mount=type=cache,target=/app/dist,id=my_app_dist,sharing=locked \\</span>
        npm run build</span>

<span class="token instruction"><span class="token keyword">FROM</span> nginx:alpine</span>

<span class="token comment"># COPY --from=builder /app/dist /app/dist</span>

<span class="token comment"># 为了更直观的说明 from 和 source 指令，这里使用 RUN 指令</span>
<span class="token instruction"><span class="token keyword">RUN</span> <span class="token options"><span class="token property">--mount</span><span class="token punctuation">=</span><span class="token string">type=cache,target=/tmp/dist,from=builder,source=/app/dist</span></span> <span class="token operator">\\</span>
    <span class="token comment"># --mount=type=cache,target/tmp/dist,from=my_app_dist,sharing=locked \\</span>
    mkdir -p /app/dist &amp;&amp; cp -r /tmp/dist/* /app/dist</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>由于 <code>BuildKit</code> 为实验特性，每个 <code>Dockerfile</code> 文件开头都必须加上如下指令</strong></p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># syntax = docker/dockerfile:experimental</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一个 <code>RUN</code> 指令执行后，<code>id</code> 为 <code>my_app_npm_module</code> 的缓存文件夹挂载到了 <code>/app/node_modules</code> 文件夹中。多次执行也不会产生多个中间层镜像。</p><p>第二个 <code>RUN</code> 指令执行时需要用到 <code>node_modules</code> 文件夹，<code>node_modules</code> 已经挂载，命令也可以正确执行。</p><p>第三个 <code>RUN</code> 指令将上一阶段产生的文件复制到指定位置，<code>from</code> 指明缓存的来源，这里 <code>builder</code> 表示缓存来源于构建的第一阶段，<code>source</code> 指明缓存来源的文件夹。</p><p>上面的 <code>Dockerfile</code> 中 <code>--mount=type=cache,...</code> 中指令作用如下：</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code>id</code></td><td><code>id</code> 设置一个标志，以便区分缓存。</td></tr><tr><td><code>target</code> (必填项)</td><td>缓存的挂载目标文件夹。</td></tr><tr><td><code>ro</code>,<code>readonly</code></td><td>只读，缓存文件夹不能被写入。</td></tr><tr><td><code>sharing</code></td><td>有 <code>shared</code> <code>private</code> <code>locked</code> 值可供选择。<code>sharing</code> 设置当一个缓存被多次使用时的表现，由于 <code>BuildKit</code> 支持并行构建，当多个步骤使用同一缓存时（同一 <code>id</code>）会发生冲突。<code>shared</code> 表示多个步骤可以同时读写，<code>private</code> 表示当多个步骤使用同一缓存时，每个步骤使用不同的缓存，<code>locked</code> 表示当一个步骤完成释放缓存后，后一个步骤才能继续使用该缓存。</td></tr><tr><td><code>from</code></td><td>缓存来源（构建阶段），不填写时为空文件夹。</td></tr><tr><td><code>source</code></td><td>来源的文件夹路径。</td></tr></tbody></table><h3 id="run-mount-type-bind" tabindex="-1"><a class="header-anchor" href="#run-mount-type-bind"><span><code>RUN --mount=type=bind</code></span></a></h3><p>该指令可以将一个镜像（或上一构建阶段）的文件挂载到指定位置。</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># syntax = docker/dockerfile:experimental</span>
<span class="token instruction"><span class="token keyword">RUN</span> <span class="token options"><span class="token property">--mount</span><span class="token punctuation">=</span><span class="token string">type=bind,from=php:alpine,source=/usr/local/bin/docker-php-entrypoint,target=/docker-php-entrypoint</span></span> <span class="token operator">\\</span>
        cat /docker-php-entrypoint</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="run-mount-type-tmpfs" tabindex="-1"><a class="header-anchor" href="#run-mount-type-tmpfs"><span><code>RUN --mount=type=tmpfs</code></span></a></h3><p>该指令可以将一个 <code>tmpfs</code> 文件系统挂载到指定位置。</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># syntax = docker/dockerfile:experimental</span>
<span class="token instruction"><span class="token keyword">RUN</span> <span class="token options"><span class="token property">--mount</span><span class="token punctuation">=</span><span class="token string">type=tmpfs,target=/temp</span></span> <span class="token operator">\\</span>
        mount | grep /temp</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="run-mount-type-secret" tabindex="-1"><a class="header-anchor" href="#run-mount-type-secret"><span><code>RUN --mount=type=secret</code></span></a></h3><p>该指令可以将一个文件(例如密钥)挂载到指定位置。</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># syntax = docker/dockerfile:experimental</span>
<span class="token instruction"><span class="token keyword">RUN</span> <span class="token options"><span class="token property">--mount</span><span class="token punctuation">=</span><span class="token string">type=secret,id=aws,target=/root/.aws/credentials</span></span> <span class="token operator">\\</span>
        cat /root/.aws/credentials</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">--secret</span> <span class="token assign-left variable">id</span><span class="token operator">=</span>aws,src<span class="token operator">=</span><span class="token environment constant">$HOME</span>/.aws/credentials <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="run-mount-type-ssh" tabindex="-1"><a class="header-anchor" href="#run-mount-type-ssh"><span><code>RUN --mount=type=ssh</code></span></a></h3><p>该指令可以挂载 <code>ssh</code> 密钥。</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code><span class="token comment"># syntax = docker/dockerfile:experimental</span>
<span class="token instruction"><span class="token keyword">FROM</span> alpine</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk add --no-cache openssh-client</span>
<span class="token instruction"><span class="token keyword">RUN</span> mkdir -p -m 0700 ~/.ssh &amp;&amp; ssh-keyscan gitlab.com &gt;&gt; ~/.ssh/known_hosts</span>
<span class="token instruction"><span class="token keyword">RUN</span> <span class="token options"><span class="token property">--mount</span><span class="token punctuation">=</span><span class="token string">type=ssh</span></span> ssh git@gitlab.com | tee /hello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">eval</span> <span class="token variable"><span class="token variable">$(</span>ssh-agent<span class="token variable">)</span></span>
$ ssh-add ~/.ssh/id_rsa
<span class="token punctuation">(</span>Input your passphrase here<span class="token punctuation">)</span>
$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">--ssh</span> <span class="token assign-left variable">default</span><span class="token operator">=</span><span class="token environment constant">$SSH_AUTH_SOCK</span> <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="docker-compose-build-使用-buildkit" tabindex="-1"><a class="header-anchor" href="#docker-compose-build-使用-buildkit"><span>docker-compose build 使用 Buildkit</span></a></h2><p>设置 <code>COMPOSE_DOCKER_CLI_BUILD=1</code> 环境变量即可使用。</p><h2 id="官方文档" tabindex="-1"><a class="header-anchor" href="#官方文档"><span>官方文档</span></a></h2>`,34)),n("ul",null,[n("li",null,[n("a",m,[e[6]||(e[6]=s("https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md")),t(a)])])])])}const g=o(l,[["render",k],["__file","buildkit.html.vue"]]),y=JSON.parse('{"path":"/index/Docker/buildx/buildkit.html","title":"使用 BuildKit 构建镜像","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Dockerfile 新增指令详解","slug":"dockerfile-新增指令详解","link":"#dockerfile-新增指令详解","children":[{"level":3,"title":"RUN --mount=type=cache","slug":"run-mount-type-cache","link":"#run-mount-type-cache","children":[]},{"level":3,"title":"RUN --mount=type=bind","slug":"run-mount-type-bind","link":"#run-mount-type-bind","children":[]},{"level":3,"title":"RUN --mount=type=tmpfs","slug":"run-mount-type-tmpfs","link":"#run-mount-type-tmpfs","children":[]},{"level":3,"title":"RUN --mount=type=secret","slug":"run-mount-type-secret","link":"#run-mount-type-secret","children":[]},{"level":3,"title":"RUN --mount=type=ssh","slug":"run-mount-type-ssh","link":"#run-mount-type-ssh","children":[]}]},{"level":2,"title":"docker-compose build 使用 Buildkit","slug":"docker-compose-build-使用-buildkit","link":"#docker-compose-build-使用-buildkit","children":[]},{"level":2,"title":"官方文档","slug":"官方文档","link":"#官方文档","children":[]}],"git":{"createdTime":1731129855000,"updatedTime":1731129855000,"contributors":[{"name":"dkyg666","email":"43946866+dkyg666@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":4.08,"words":1224},"filePathRelative":"index/Docker/buildx/buildkit.md","localizedDate":"2024年11月9日","excerpt":"\\n<p><strong>BuildKit</strong> 是下一代的镜像构建组件，在 <a href=\\"https://github.com/moby/buildkit\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://github.com/moby/buildkit</a> 开源。</p>\\n<p><strong>注意：如果您的镜像构建使用的是云服务商提供的镜像构建服务（腾讯云容器服务、阿里云容器服务等），由于上述服务提供商的 Docker 版本低于 18.09，BuildKit 无法使用，将造成镜像构建失败。建议使用 BuildKit 构建镜像时使用一个新的 Dockerfile 文件（例如 Dockerfile.buildkit）</strong></p>"}');export{g as comp,y as data};
