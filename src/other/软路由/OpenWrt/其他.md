# 其他



## docker导出镜像

<details>
  <summary>【查看详情】</summary>

```
#!/bin/bash
# 设置导出镜像的目录
EXPORT_DIR="/mnt/alist/share/images"
# 确保导出目录存在
mkdir -p "$EXPORT_DIR"
# 获取所有的镜像并导出
IMAGES=$(docker images xhofe/alist --format '{{.Repository}}:{{.Tag}}')
# 遍历所有的镜像
for IMAGE in $IMAGES; do
    # 分割镜像仓库名和标签
    IFS=":" read -r REPOSITORY TAG <<< "$IMAGE"
    # 将仓库名中的斜杠替换为下划线
    SAFE_REPOSITORY=${REPOSITORY//\//_}
    # 构造导出文件的名称
    EXPORT_FILE="${SAFE_REPOSITORY}_${TAG}.tar"
    EXPORT_PATH="$EXPORT_DIR/$EXPORT_FILE"
    # 检查镜像是否存在，如果存在则导出
    if docker image inspect "${REPOSITORY}:${TAG}" >/dev/null 2>&1; then
        docker save -o "$EXPORT_PATH" "${REPOSITORY}:${TAG}"
        echo "Exported ${REPOSITORY}:${TAG} to $EXPORT_PATH"
        # 创建 MD5 文件，只显示 MD5 值和文件名
        md5sum "$EXPORT_PATH" | awk '{print $1, "'$EXPORT_FILE'"}' > "$EXPORT_PATH.md5"
        echo "MD5 checksum saved to $EXPORT_PATH.md5"
        # 将镜像文件和 MD5 文件打包成 .tar.gz 压缩文件
        tar -czf "${EXPORT_PATH}.gz" -C "$EXPORT_DIR" "$EXPORT_FILE" "$EXPORT_FILE.md5"
        echo "Compressed ${EXPORT_FILE} and ${EXPORT_FILE}.md5 into ${EXPORT_PATH}.gz"
          else
        echo "Error: ${REPOSITORY}:${TAG} does not exist"
    fi
done
echo "Export and compression process completed."

```

 </details>



## Git提交代码

<details>
  <summary>【查看详情】</summary>



```

git init                    初始化一个新仓库
git branch -m master main   将默认的主分支名称从“master”更改为“main”
git add -A                  将所有更改的文件添加到暂存区
git commit -m 'deploy'      提交这些更改，并添加提交信息“deploy”。

# 如果发布到 https://<USERNAME>.github.io
# git push -f git@github.com:<USERNAME>/<USERNAME>.github.io.git main

# 如果发布到 https://<USERNAME>.github.io/<REPO>

git push -f git@github.com:ni'de.git main


```

 </details>


 ## 配置alist反向代理

<details>
  <summary>【查看详情】</summary>

我们进入nginx的配置文件夹
```
NGINX默认安装路径
/usr/sbin/nginx：主程序
/etc/nginx：存放配置文件
/usr/share/nginx：存放静态文件
/var/log/nginx：存放日志
/run/nginx.pid nginx pid路径

```

```
cd /etc/nginx/conf.d
```
新建一个alist的反代配置文件
```
nano alist.conf
```
在文件中放入如下内容
```
server {
    listen 80;
    listen [::]:80;
    server_name example.com;  # 替换为你的域名

    # 强制重定向到 HTTPS
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name example.com;  # 替换为你的域名

    ssl_certificate /etc/nginx/keyfile/cert.pem;  
    ssl_certificate_key /etc/nginx/keyfile/key.pem;  

    # SSL 配置（可选）
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers on;

    location / {
               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
               proxy_set_header X-Forwarded-Proto $scheme;
               proxy_set_header Host $http_host;
               proxy_set_header X-Real-IP $remote_addr;
               proxy_set_header Range $http_range;
               proxy_set_header If-Range $http_if_range;
               proxy_redirect off;
               proxy_pass http://127.0.0.1:5244;     #反代不同服务修改这里
               # the max size of file to upload
               client_max_body_size 20000m;
             }
}


```
同时我们关闭直接对公网ip和未配置域名的访问
```
nano close.conf
```
放置如下内容
```
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;

    # 对未配置的域名返回 444
    return 444;
}

server {
    listen 443 ssl default_server;
    listen [::]:443 ssl default_server;
    server_name _;

    ssl_certificate /etc/nginx/keyfile/cert.pem;  
    ssl_certificate_key /etc/nginx/keyfile/key.pem;


    # 对未配置的域名返回 444
    return 444;
}

```
重启nginx反代即生效
```
sudo systemctl restart nginx
```



手动切割日志文件

默认 Nginx 的日志都是输出到一个文件中的，是不会按照日期进行切割的，这样会导致文件越来越大，不利于查看。

我们可以编写一个脚本文件，通过命令来进行切割。

例如命令为：cut_nginx_log.sh
```
#!/bin/bash
# 日志路径
LOG_PATH="/usr/local/nginx/logs"

# 生成一个时间的字符串
RECORD_TIME=$(date -d "yesterday" +%Y-%m-%d-%H-%M-%S)

# nginx的PID
PID=/usr/local/nginx/logs/nginx.pid

# 移动文件
mv ${LOG_PATH}/access.log ${LOG_PATH}/access.${RECORD_TIME}.log
mv ${LOG_PATH}/error.log ${LOG_PATH}/error.${RECORD_TIME}.log

# 向Nginx主进程发送信号，用于重新打开日志文件
kill -USR1 `cat $PID`

```

编写好了，赋予文件执行权限。然后执行脚本文件：
```
sudo chmod +x cut_nginx_log.sh

./cut_nginx_log.sh

```


 </details>



## 通过公钥进行ssh连接

<details>
  <summary>【查看详情】</summary>

这篇文章介绍了使用ssh公钥连接设备的方法

注意

注1、建议使用1.2法二在本地生成密钥。

## 1 生成密钥

### 1.1 法一：在设备生成密钥[**不推荐**]

我们先正常的ssh连接到设备，输入如下命令，然后一直回车，生成密钥。

```
ssh-keygen -m PEM -t rsa -b 4096 
```

然后我们进入自己家目录下的`.ssh`文件夹。

```
cd .ssh 
```

如果输入`ls`命令可以看到生成了两个文件，`id_rsa`和`id_rsa.pub`，`id_rsa.pub`就是我们的公钥文件，我们用如下命令将公钥保存在验证文件中。

```
cat id_rsa.pub >> authorized_keys 
```

然后我们分别授予验证文件和.ssh文件夹对应的读写权限

```
chmod 600 authorized_keys 
chmod 700 ~/.ssh 
```

然后我们将私钥文件`id_rsa`下载到本地，用我们的ssh工具导入私钥文件，进行连接尝试。  

### 1.2 法二：在本地生成密钥

我们`Win+R`再打开的界面输入`cmd`回车，然后输入如下命令，一直回车生成密钥。

```
ssh-keygen -m PEM -t rsa -b 4096 
```

然后我们正常ssh连接到设备，然后创建并进入.ssh文件夹

```
mkdir -p .ssh && cd .ssh 
```

然后创建`authorized_keys`验证文件

```
nano authorized_keys 
```

在c盘下的`用户`文件夹，`自己用户名`的文件夹，`.ssh`文件夹，将里面的`id_rsa.pub`文件右键打开方式，使用记事本打开，将全部内容复制到`authorized_keys`内，并保存退出。

然后我们分别授予验证文件和.ssh文件夹对应的读写权限

```
chmod 600 authorized_keys 
chmod 700 ~/.ssh 
```

然后我们可以直接断开连接，然后ssh到设备查看是否需要密码，如已经不再需要密码直接连接，公钥即已经配置好了。

我们也可以在任意支持ssh连接的软件导入`.ssh`文件夹内的私钥文件`id_rsa`即可实现直接连接。

## 2 关闭ssh的账号密码登陆

我们尝试公钥连接成功后，我们关闭ssh的密码连接，我们打开ssh的配置文件

```
sudo nano /etc/ssh/sshd_config 
```

我们找到`#PasswordAuthentication yes`这行，将其修改为

```
PasswordAuthentication no 
```

然后保存退出，重启sshd配置生效

```
sudo service sshd restart
```



 </details>


## Docker

<details>
  <summary>【查看详情】</summary>
### 安装docker

安装Docker需要将我们的计算机联网，[安装yum](https://so.csdn.net/so/search?q=安装yum&spm=1001.2101.3001.7020)工具

```
yum install -y yum-utils 
```

更新本地镜像

```
# 设置docker镜像源
yum-config-manager \
    --add-repo \
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
    
yum makecache fast
```

直接使用`yum`命令即可安装 Docker。

```
yum install docker-ce docker-ce-cli containerd.io
```

```
yum install docker-ce-26.1.4 docker-ce-cli-26.1.4 containerd.io-1.6.33
```

```bash
安装指定版本的DockerEngine（可选）
列出仓库存在的版本信息：
apt-cache madison docker-ce

sudo apt-get install docker-ce=5:26.1.4-1~ubuntu.22.04~jammy docker-ce-cli=5:26.1.4-1~ubuntu.22.04~jammy containerd.io=1.6.33-1
```

### 启动Docker

通过命令启动docker：

```
systemctl start docker  # 启动服务
systemctl status docker  # 查看状态
systemctl stop docker  # 停止服务
systemctl restart docker  # 重启服务
```

然后输入命令，可以查看docker版本：

```
docker -v
```

出现版本才算成功

为了让 Docker 在每次重启系统的时候能i自动运行，还需要设置自启动：

```
systemctl enable docker
```

```
# 关闭
systemctl stop firewalld
# 禁止开机启动防火墙
systemctl disable firewalld
```

卸载Docker

```
# 卸载docker
yum remove docker-ce docker-ce-cli containerd.io

# 删除docker docker默认工作路径
rm -rf /var/lib/docker

rm -rf /etc/docker
rm -rf /run/docker
rm -rf /var/lib/dockershim
rm -rf /var/lib/docker
```

卸载脚本

```
#!/bin/bash
systemctl stop docker
yum remove docker \
                  docker-ce* \
                  docker-buildx-plugin \
                  docker-compose-plugin \
                  docker-scan-plugin \
                  containerd.io \
                  container-selinux
rm -rf /var/lib/docker
rm -rf /etc/docker/daemon.json
rm -rf /etc/docker
rm -rf /run/docker
rm -rf /var/lib/dockershim
rm -rf /var/lib/docker
yum list installed | grep docker
```



```
docker exec -it 容器id /bin/bash
docker attach 
docker commit -m="描述信息" -a="作者" 容器ID 目标镜像名:[TAG]
docker save -o /路径/镜像名.tar 镜像名:[TAG]
docker load -i /路径/镜像名.tar

docker inspect 容器id

docker builder prune 清除构建缓存
```



```
卸载docker
1.删除docker的所有包
apt-get autoremove docker docker-ce docker-engine  docker.io  containerd runc
2.查看docker是否卸载干净
dpkg -l | grep docker

dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P
3.删除相关插件
apt-get autoremove docker-ce-*
4.删除docker配置目录
rm -rf /etc/systemd/system/docker.service.d

rm -rf /var/lib/docker
5.确定docker卸载完毕
docker --version
```



## compose

```
COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep 'tag_name' | cut -d\" -f4)

sh -c "curl -L https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose"

sudo curl -L "https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

sudo chmod +x /usr/local/bin/docker-compose

sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose



$ docker-compose --version
docker-compose version 1.29.1, build 1110ad01


rm  /usr/bin/docker-compose
```

```
将docker-compose赋予可执行权限
chmod +x /usr/local/bin/docker-compose
建立连接
ln -s /usr/local/bin/docker-compose docker-compose
确认是否安裝成功
docker-compose -v
卸载
sudo rm /usr/local/bin/docker-compose

mkdir 创建工作文件夹
touch docker-compose.yml
 启动服务
docker-compose up -d
停止服务
docker-compose down
列出所有运行容器
docker-compose ps
查看服务日志
docker-compose logs
构建或
docker-compose build者重新构建服务
启动服务
docker-compose start
停止已运行的服务
docker-compose stop
重启服务
docker-compose restart

 
```



设置镜像仓库

```
vi /etc/docker/daemon.json

# 内容如下：
{
  "registry-mirrors": [
    "https://docker.m.daocloud.io"
  ]
}

{
  "registry-mirrors": [
    "https://1996099.xyz"
  ]
}

# 退出并保存
:wq

# 使配置生效
systemctl daemon-reload

# 重启Docker
systemctl restart docker

```



# Reference

- [docker国内镜像源配置及走代理设置\_docker 镜像代理-CSDN博客](https://blog.csdn.net/Lichen0196/article/details/137355517)

# 说明

- 首先，自己要解决网络问题，这里省略一万字...

- 注意：配置了`daemon.json`的，去把里面的镜像源都先删掉，可以先备份一下。

# 命令

- 在docker的进程服务文件夹配置代理，如果没有我们就新建这个文件夹：

```bash
sudo mkdir /usr/lib/systemd/system/docker.service.d
```

```
cd /usr/lib/systemd/system/docker.service.d
```

- 然后在`docker.service.d`文件夹里新建我们的代理文件`proxy.conf`

```bash
sudo vim proxy.conf
```

- 并把文件写如下面这个格式，我这里是本机的客户端，自己按自己的客户端写

```
[Service]
Environment="HTTP_PROXY=http://192.168.18.144:7890/"
Environment="HTTPS_PROXY=http://192.168.18.144:7890/"
```

- `:wq`保存并退出`proxy.conf`文件，和更改镜像源一样，重启docker，并重启daemon进程。

```bash
sudo systemctl daemon-reload
```

```bash
sudo systemctl restart docker
```

- 最后，验证一下是否修改成功，出现了代理信息表示成功。

```bash
docker info
```

#### CentOS 7.x 修改固定IP地址

进入centos7虚拟机窗口

输入：

```
vi  /etc/sysconfig/network-scripts/ifcfg-ens33
```







 </details>







## Alist

<details>
  <summary>【查看详情】</summary>

# 一键脚本

**安装**

```bash
curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s install
```

**更新**

```bash
curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s update
```

**卸载**

```bash
curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s uninstall
```

## **自定义路径**

默认安装在 `/opt/alist` 中。 自定义安装路径，将安装路径作为第二个参数添加，必须是绝对路径（如果路径以 alist 结尾，则直接安装到给定路径，否则会安装在给定路径 alist 目录下），如 安装到 `/root`：

正式版

```bash
# Install
curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s install /root
# update
curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s update /root
# Uninstall
curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s uninstall /root
```

- 启动: `systemctl start alist`
- 关闭: `systemctl stop alist`
- 状态: `systemctl status alist`
- 重启: `systemctl restart alist`

## [#](https://alist.nn.ci/zh/guide/install/script.html#获取密码)**获取密码**

需要进入脚本安装AList的目录文件夹內执行如下命令

#### [#](https://alist.nn.ci/zh/guide/install/script.html#低于v3-25-0版本)低于v3.25.0版本

```bash
./alist admin
```

#### [#](https://alist.nn.ci/zh/guide/install/script.html#高于v3-25-0版本)高于v3.25.0版本

3.25.0以上版本将密码改成加密方式存储的hash值，无法直接反算出密码，如果忘记了密码只能通过重新 **`随机生成`** 或者 **`手动设置`**

```bash
# 随机生成一个密码
./alist admin random
# 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码
./alist admin set NEW_PASSWORD
```

# 手动安装

## **获取 AList**

打开 [AList Releaseopen in new window](https://github.com/Xhofe/alist/releases) 下载待部署系统对应的文件。最新版的前端已经和后端打包好了，不用再下载前端文件了。

xxxx 指的是不同系统/架构对应的名称，一般 Linux-x86/64 为 alist-linux-amd64

手动安装如果有如下提示：是因为[你的 GLIBC 版本太低](https://alist.nn.ci/zh/faq/why.html#lib64-libc-so-6-version-glibc-2-28-not-found-required-by-alist-或者-accept-function-not-implemented)，建议下载 musl 版本

```txt
lib64/libc.so.6: version `GLIBC_2.28' not found (required by ./alist)  
#或者
accept: function not implemented
```

当你看到 `start server@0.0.0.0:5244` 的输出，之后没有报错，说明操作成功。 第一次运行时会输出初始密码。程序默认监听 5244 端口。 现在打开 `http://ip:5244` 可以看到登录页面，WebDAV 请参阅 [WebDav](https://alist.nn.ci/zh/guide/webdav.html)。

## [#](https://alist.nn.ci/zh/guide/install/manual.html#手动运行)**手动运行**

v3.25.0以上版本将密码改成加密方式存储的hash值，无法直接反算出密码，如果忘记了密码只能通过重新 **`随机生成`** 或者 **`手动设置`**

Linux

```bash
# 解压下载的文件，得到可执行文件：
tar -zxvf alist-xxxx.tar.gz
# 授予程序执行权限：
chmod +x alist
# 运行程序
./alist server

# 获得管理员信息 以下两个不同版本，新版本也有随机生成和手动设置
# 低于v3.25.0版本
./alist admin

# 高于v3.25.0版本
# 随机生成一个密码
./alist admin random
# 手动设置一个密码 `NEW_PASSWORD`是指你需要设置的密码
./alist admin set NEW_PASSWORD
```

## [#](https://alist.nn.ci/zh/guide/install/manual.html#守护进程)**守护进程**

Linux

使用任意方式编辑 `/usr/lib/systemd/system/alist.service` 并添加如下内容，其中 path_alist 为 AList 所在的路径

```ini
[Unit]
Description=alist
After=network.target
 
[Service]
Type=simple
WorkingDirectory=path_alist
ExecStart=path_alist/alist server
Restart=on-failure
 
[Install]
WantedBy=multi-user.target
```

然后，执行 `systemctl daemon-reload` 重载配置，现在你可以使用这些命令来管理程序：

- 启动: `systemctl start alist`
- 关闭: `systemctl stop alist`
- 配置开机自启: `systemctl enable alist`
- 取消开机自启: `systemctl disable alist`
- 状态: `systemctl status alist`
- 重启: `systemctl restart alist`

守护进程不配置? [**视频教程**open in new window](https://www.bilibili.com/video/BV1rF41197Qv?t=187.0)

相关信息

对于所有平台，您可以使用以下命令来静默启动、停止和重新启动。 （v3.4.0 及更高版本）

```bash
# 携带`--force-bin-dir`参数启动服务
alist start
# 通过pid停止服务
alist stop
# 通过pid重启服务
alist restart
```



## [#](https://alist.nn.ci/zh/guide/install/manual.html#如何更新)**如何更新**

下载新版Alist，把之前的替换了即可。



- 启动: `systemctl start alist`
- 关闭: `systemctl stop alist`
- 状态: `systemctl status alist`
- 重启: `systemctl restart alist`

## [#](https://alist.nn.ci/zh/guide/install/manual.html#获取密码)**获取密码**

需要进入脚本安装AList的目录文件夹內执行如下命令

#### [#](https://alist.nn.ci/zh/guide/install/manual.html#低于v3-25-0版本)低于v3.25.0版本

```bash
./alist admin
```

#### [#](https://alist.nn.ci/zh/guide/install/manual.html#高于v3-25-0版本)高于v3.25.0版本

3.25.0以上版本将密码改成加密方式存储的hash值，无法直接反算出密码，如果忘记了密码只能通过重新 **`随机生成`** 或者 **`手动设置`**

```bash
# 随机生成一个密码
./alist admin random
# 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码
./alist admin set NEW_PASSWORD
```



# 使用 Docker

#### **低于v3.25.0版本**



```bash
docker exec -it alist ./alist admin
```

#### [#](https://alist.nn.ci/zh/guide/install/docker.html#高于v3-25-0版本)**高于v3.25.0版本**

3.25.0以上版本将密码改成加密方式存储的hash值，无法直接反算出密码，如果忘记了密码只能通过重新 **`随机生成`** 或者 **`手动设置`**



```bash
# 随机生成一个密码
docker exec -it alist ./alist admin random
# 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码
docker exec -it alist ./alist admin set NEW_PASSWORD
```

## [#](https://alist.nn.ci/zh/guide/install/docker.html#发行版本)**发行版本**

##### [#](https://alist.nn.ci/zh/guide/install/docker.html#docker-cli)**docker-cli**



```bash
docker run -d --restart=unless-stopped -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name="alist" xhofe/alist:latest
```

##### [#](https://alist.nn.ci/zh/guide/install/docker.html#docker-compose)**docker-compose**



```yaml
version: '3.3'
services:
    alist:
        image: 'xhofe/alist:latest'
        container_name: alist
        volumes:
            - '/etc/alist:/opt/alist/data'
        ports:
            - '5244:5244'
        environment:
            - PUID=0
            - PGID=0
            - UMASK=022
        restart: unless-stopped
```

服务运行之后，容器默认的时区为UTC时区，如果你想指定容器运行的时区，则可以通过传递此变量来实现：`-e "TZ=Asia/Shanghai"`。

### [#](https://alist.nn.ci/zh/guide/install/docker.html#使用-aria2-离线下载)**使用 aria2 离线下载**

如果你想使用aria2离线下载，我们推荐你使用这个[imageopen in new window](https://hub.docker.com/r/xhofe/alist-aria2)，它预装了aria2。

### [#](https://alist.nn.ci/zh/guide/install/docker.html#开发版本)**开发版本**

仅适用于 amd64/arm64。不推荐，这可能无法正常工作。

##### [#](https://alist.nn.ci/zh/guide/install/docker.html#docker-cli-1)**docker-cli**

```bash
docker run -d --restart=unless-stopped -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name="alist" xhofe/alist:beta
```

##### [#](https://alist.nn.ci/zh/guide/install/docker.html#docker-compose-1)**docker-compose**

```bash
#创建一个目录
mkdir /etc/alist
#进入该目录
cd /etc/alist
#下载docker-compose.yml文件
wget https://alist.nn.ci/docker-compose.yml
#运行容器
docker-compose up -d
```

**你也可以自行创建一个包含以下内容的`docker-compose.yml`文件**



```yaml
version: '3.3'
services:
    alist:
        image: 'xhofe/alist:beta'
        container_name: alist
        volumes:
            - '/etc/alist:/opt/alist/data'
        ports:
            - '5244:5244'
        environment:
            - PUID=0
            - PGID=0
            - UMASK=022
        restart: unless-stopped
```



### **用户/组标识符**

当使用卷（`-v` 标志）权限问题时，主机操作系统和容器之间可能会出现权限问题，我们通过允许您指定用户 `PUID` 和组 `PGID` 来避免此问题。

确保主机上的任何卷目录都归您指定的同一用户所有，任何权限问题都会像魔术一样消失。

在这种情况下，`PUID=1000` 和 `PGID=1000`，要找到你的使用 `id user`，如下所示：

```bash
  $ id username
    uid=1000(dockeruser) gid=1000(dockergroup) groups=1000(dockergroup)
```

### [#](https://alist.nn.ci/zh/guide/install/docker.html#手动编译-docker-镜像)**手动编译 Docker 镜像**

安装 docker，克隆仓库后进入仓库根目录，无需其他准备

basic

```bash
docker build -t xhofe/alist:latest .
```

Dockerfile构建

```

FROM alpine:edge
WORKDIR /opt/alist/

RUN apk update && \
    apk upgrade --no-cache && \
    apk add --no-cache bash ca-certificates su-exec tzdata wget; \
    rm -rf /var/cache/apk/*

RUN wget https://github.com/alist-org/alist/releases/latest/download/alist-linux-musl-amd64.tar.gz \
&& tar -zxvf alist-linux-musl-amd64.tar.gz && rm -rf alist-linux-musl-amd64.tar.gz && chmod +x alist

ENV PUID=0 PGID=0 UMASK=022
VOLUME /opt/alist/data/
EXPOSE 5244 5245
CMD ["/opt/alist/alist", "server"]

```



WORKDIR /anmiao
ADD ./alist-linux-amd64.tar.gz /anmiao

EXPOSE 5244

CMD ["/anmiao/alist", "server"]



docker build -t dkyg/alist:latest .

docker builder prune

```

FROM alpine:edge
WORKDIR /opt/alist/
RUN apk update && \
    apk upgrade --no-cache && \
    apk add --no-cache bash ca-certificates su-exec tzdata; \
    rm -rf /var/cache/apk/*
ADD ./alist-linux-musl-amd64.tar.gz /opt/alist/
ENV PUID=0 PGID=0 UMASK=022
VOLUME /opt/alist/data/
EXPOSE 5244 5245
CMD ["/opt/alist/alist", "server"]
```



其他

```
FROM python:3.12.4-alpine

ENV TZ=Asia/Shanghai

RUN apk update \
    && apk upgrade \
    && apk add bash \
    && rm -rf \
        /tep \
        /var/lib/apt/lists \
        /var/tmp

COPY requirements.txt requirements.txt

RUN pip install --upgrade pip \
    && pip install --no-cache-dir -r requirements.txt \
    && rm -rf requirements.txt

COPY app /app

VOLUME ["/config", "/logs", "/media"]
CMD python /app/main.py

```



# 从源码运行

## **环境准备**

首先，你需要一个有`git`，`nodejs`，`pnpm`，`golang>=1.20`，`gcc`的环境

## [#](https://alist.nn.ci/zh/guide/install/source.html#构建前端)**构建前端**

使用 `git clone --recurse-submodules https://github.com/alist-org/alist-web.git` 克隆前端 ，执行 `pnpm install && pnpm build` 得到 dist 目录下的目标文件

## [#](https://alist.nn.ci/zh/guide/install/source.html#构建后端)**构建后端**

克隆 [https://github.com/alist-org/alistopen in new window](https://github.com/alist-org/alist) ，将上一步的 `dist` 目录复制到项目下的 `public` 目录下，然后执行：



```bash
appName="alist"
builtAt="$(date +'%F %T %z')"
goVersion=$(go version | sed 's/go version //')
gitAuthor=$(git show -s --format='format:%aN <%ae>' HEAD)
gitCommit=$(git log --pretty=format:"%h" -1)
version=$(git describe --long --tags --dirty --always)
webVersion=$(wget -qO- -t1 -T2 "https://api.github.com/repos/alist-org/alist-web/releases/latest" | grep "tag_name" | head -n 1 | awk -F ":" '{print $2}' | sed 's/\"//g;s/,//g;s/ //g')
ldflags="\
-w -s \
-X 'github.com/alist-org/alist/v3/internal/conf.BuiltAt=$builtAt' \
-X 'github.com/alist-org/alist/v3/internal/conf.GoVersion=$goVersion' \
-X 'github.com/alist-org/alist/v3/internal/conf.GitAuthor=$gitAuthor' \
-X 'github.com/alist-org/alist/v3/internal/conf.GitCommit=$gitCommit' \
-X 'github.com/alist-org/alist/v3/internal/conf.Version=$version' \
-X 'github.com/alist-org/alist/v3/internal/conf.WebVersion=$webVersion' \
"
go build -ldflags="$ldflags" .
```







# 反向代理

## **nginx**

在网站配置文件的 server 字段中添加



```conf
location / {
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header Host $http_host;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header Range $http_range;
	proxy_set_header If-Range $http_if_range;
  proxy_redirect off;
  proxy_pass http://127.0.0.1:5244;
  # the max size of file to upload
  client_max_body_size 20000m;
}
```

如果需要使用HTTP/3，需要将对应`HOST`行修改为：



```conf
proxy_set_header Host $host:$server_port;
```

这样修改后的配置同时也可以兼容HTTP/2及更低版本的请求。



### **如何对子目录进行反向代理？**

使用 nginx 反向代理到 [https://nn.ci/alistopen in new window](https://nn.ci/alist) 的示例：

- 正常安装
- 将 [site_url](https://alist.nn.ci/zh/config/configuration.html#site_url) 设置为 `https://nn.ci/alist` 或者仅`/alist`, 然后重启alist
- 在 nginx 中添加反向代理配置

```nginx
location /alist/ {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Range $http_range;
	  proxy_set_header If-Range $http_if_range;
    proxy_redirect off;
    proxy_pass http://127.0.0.1:5244/alist;
    # the max size of file to upload
    client_max_body_size 20000m;
}
```



### 自动渐变背景[](https://alist-doc.nn.ci/docs/style#自动渐变背景)

```html
<!--放在自定义头部-->

<style>
/*渐变背景CSS */
#canvas-basic {
    position: fixed;
    display: block;
    width: 100%;
    height: 100%;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: -999;
}
 .hope-ui-light {
--hope-colors-background: #f7f8fa00 !important;
}
.hope-ui-dark {
--hope-colors-background: #f7f8fa00 !important;
}
</style>


<!--放在自定义body-->

<!-- 渐变背景初始化 -->
<canvas id="canvas-basic"></canvas> 
<script src="https://npm.elemecdn.com/granim@2.0.0/dist/granim.min.js"></script>
<script>
var granimInstance = new Granim({
    element: '#canvas-basic',
    direction: 'left-right',
    isPausedWhenNotInView: true,
    states : {
        "default-state": {
            gradients: [
                ['#a18cd1', '#fbc2eb'],
                 ['#fff1eb', '#ace0f9'],
                 ['#d4fc79', '#96e6a1'],
                 ['#a1c4fd', '#c2e9fb'],
                 ['#a8edea', '#fed6e3'],
                 ['#9890e3', '#b1f4cf'],
                 ['#a1c4fd', '#c2e9fb'],
                 ['#fff1eb', '#ace0f9']
           
            ]
        }
    }
});
</script>
```







 </details>







## Nginx

<details>
  <summary>【查看详情】</summary>

CentOS 7 gcc编译安装Nginx



##### **安装所需环境**

Nginx是C语言开发，建议在Linux上运行，当然，也可以安装Windows版本，本篇则使用Linux CentOS 7作为安装环境。

##### **一、gcc安装**

安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：

代码语言：javascript

复制

```
yum install gcc gcc-c++
```

##### **二、pcre pcre-devel 安装**

PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。Nginx的http 模块使用pcre来解析正则表达式，所以需要在Linux上安装pcre库，pcre-devel 是使用pcre开发的一个二次开发库。Nginx也需要此库。命令：

代码语言：javascript

复制

```
yum install -y pcre pcre-devel
```

##### **三、 zlib安装**

zlib 库提供了很多种压缩和解压缩的方式， Nginx使用zlib对http包的内容进行gzip，所以需要在Linux Centos 7上安装zlib库。

代码语言：javascript

复制

```
yum install -y zlib zlib-devel
```

##### **四、openssl安装**

OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。 Nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在Linux Centos 7安装OpenSSL库。

代码语言：javascript

复制

```
yum install -y openssl openssl-devel



# 解压到当前目录
tar zxvf openssl-1.0.2k.tar.gz
# 进入目录
cd openssl-1.0.2k
# 配置编译，指定安装目录
./config
# 进行编译并安装
make && make install
备份之前 OpenSSL 版本的文件，以方便恢复。



echo "/usr/local/lib64/" >> /etc/ld.so.conf

ldconfig

mv /usr/bin/openssl /usr/bin/openssl.old

ln -s /usr/local/bin/openssl /usr/bin/openssl

openssl version -a



方法2

cd openssl-1.0.2k

#./config -fPIC --prefix=/usr/local/openssl/ enable-shared

./config shared zlib

make

make install

mv /usr/bin/openssl /usr/bin/openssl.bak

mv /usr/include/openssl /usr/include/openssl.bak

ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl

ln -s /usr/local/openssl/include/openssl /usr/include/openssl

ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1

ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1

echo “/usr/local/openssl/lib” >> /etc/ld.so.conf

ldconfig -v

5、查看是否升级成功[root@localhost ~]# openssl version -a

解决 openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory错误问题

在Centos7上编译安装openssl后，运行openssl version出现如下错误：

openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory

这是由于openssl库的位置不正确造成的。解决方法是在root用户下执行：ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1

ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1


```

##### **五、下载Nginx**

**1. 官网下载** 直接下载.tar.gz安装包，地址：https://nginx.org/en/download.html

------

**2. wget下载** 使用wget命令下载（推荐）。确保系统已经安装了wget，如果没有安装，执行 yum install wget 安装。我下载的是1.26.0版本，这个是目前的稳定版。

代码语言：javascript

复制

```
wget -c https://nginx.org/download/nginx-1.26.0.tar.gz
```

------

**3. 解压** 依然是直接命令：

代码语言：javascript

复制

```
tar -zxvf nginx-1.26.0.tar.gz
cd nginx-1.26.0
```

------

**4. 配置** 其实在 nginx-1.26.0 版本中你就不需要去配置相关东西，默认就可以了。当然，如果你要自己配置目录也是可以的。

- 4.1 使用默认配置

代码语言：javascript

复制

```
# Ubuntu中nginx安装
sudo apt update
sudo apt install build-essential
sudo apt install libpcre3 libpcre3-dev
sudo apt install zlib1g zlib1g-dev
sudo apt install openssl libssl-dev

./configure

./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module

##openssl源解压路径

./configure --prefix=/usr/local/nginx --with-http_stub_status_module  --with-http_ssl_module --with-openssl=/root/openssl-1.1.1s
```

- 4.2 自定义配置（不推荐）

代码语言：javascript

复制

```
./configure \
--prefix=/usr/local/nginx \
--conf-path=/usr/local/nginx/conf/nginx.conf \
--pid-path=/usr/local/nginx/conf/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/temp/nginx/client \
--http-proxy-temp-path=/var/temp/nginx/proxy \
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
--http-scgi-temp-path=/var/temp/nginx/scgi
```

**注：**将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录

------

**5. 编译安装**

代码语言：javascript

复制

```
make
make install
```

------

**6. 查找安装路径**

代码语言：javascript

复制

```
whereis nginx
```

------

**7. 启动、停止nginx**

代码语言：javascript

复制

```
cd /usr/local/nginx/sbin/
./nginx 
./nginx -s stop
./nginx -s quit
./nginx -s reload
```

------

代码语言：javascript

复制

```
# 注：启动时报80端口被占用:
nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)
```

解决办法：安装net-tool包：yum install net-tools

代码语言：javascript

复制

```
./nginx -s quit # 此方式停止步骤是待nginx进程处理任务完毕进行停止。
./nginx -s stop # 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。
```

------

**8. 查询nginx进程**

代码语言：javascript

复制

```
ps aux|grep nginx
```

------

**9. 重启 nginx**

- 9.1 先停止再启动（推荐）： 对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下：

代码语言：javascript

复制

```
./nginx -s quit
./nginx
```

- 9.2 重新加载配置文件： 当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用-s reload不用先停止 ngin x再启动 nginx 即可将配置信息在 nginx 中生效，如下：

代码语言：javascript

复制

```
./nginx -s reload
```

------

**10. 启动成功** 在浏览器可以看到这样的页面，即表示启动成功

------

##### **六、开机自启动**

即在rc.local增加启动代码就可以了。

代码语言：javascript

复制

```
vi /etc/rc.local
# 增加如下代码
/usr/local/nginx/sbin/nginx
```

设置执行权限：

代码语言：javascript

复制

```
chmod 755 rc.local
nginx-rclocal.png
关闭防火墙
systemctl stop firewalld.service
systemctl disable firewalld.service
放行端口
firewall-cmd --zone=public --add-port=80/tcp --permanent

```



#### **nginx systemctl启动配置**

```
vi /usr/lib/systemd/system/nginx.service

chmod +x /usr/lib/systemd/system/nginx.service

（1）进入 cd /usr/local/nginx/conf/ 目录，编辑配置文件nginx.conf ；
（2）在配置文件中有个注释的地方： #pid        logs/nginx.pid;　　　
（3）将注释放开，并修改为：pid    /usr/local/nginx/logs/nginx.pid;


[Unit]
Description=The nginx HTTP and reverse proxy server
After=syslog.target network.target remote-fs.target nss-lookup.target

[Service]
Type=forking
PIDFile=/usr/local/nginx/logs/nginx.pid  
ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf
ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/usr/local/nginx/sbin/nginx -s stop
ExecQuit=/usr/local/nginx/sbin/nginx -s quit
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```



3.启动服务

```
在启动服务之前，需要先重载systemctl命令
systemctl daemon-reload

ps -ef | grep nginx

systemctl start nginx.service
systemctl stop nginx.service
systemctl restart nginx.service

systemctl status nginx.service      nginx状态

systemctl enable nginx.service      开机自启


备份nginx conf

cp /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf.bak2

```

#### **卸载 nginx**

```
#卸载nginx
whereis nginx

find / -name nginx

rm -rf /usr/local/nginx /usr/local/sbin/nginx

yum remove nginx
```



NGINX默认配置

```

#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
   
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
    include /usr/local/nginx/conf/conf.d/*.conf;

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}



```




 </details>





## OpenWrt扩容overlay

<details>
  <summary>【查看详情】</summary>

此教程根据E-SIR大神视频整理，侵删
overlay分区扩容教程
（此教程仅适用于E-SIR大神制作的固件 ）

ssh连接你的X86-openwrt路由器

```
Microsoft Windows [版本 10.0.19041.450]

(c) 2021 Microsoft Corporation. 保留所有权利。

 

PS C:\Users\ASUS> ssh root@192.168.5.1

root@192.168.5.1's password:

BusyBox v1.31.1 () built-in shell (ash)
```



_______                     ________        __

 |       |.-----.-----.-----.|  |  |  |.----.|  |_

 |   -   ||  _  |  -__|     ||  |  |  ||   _||   _|

 |_______||   __|_____|__|__||________||__|  |____|

          |__| W I R E L E S S   F R E E D O M

--------------------------------------------------

 OpenWrt GDQ v1.1[2021] | by "eSir PlayGround"

--------------------------------------------------

**root@OpenWrt:~# lsblk**

NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT

loop0    7:0    0 51.4M  0 loop /mnt/loop0

sda      8:0    0  7.5G  0 disk

├─sda1   8:1    0   16M  0 part /mnt/sda1

└─sda2   8:2    0  300M  0 part /rom

**root@OpenWrt:~# cfdisk**

```
如果没有cfdisk命令，则使用 opkg install cfdisk 安装）

因为我的系统使用的是固态硬盘，所以默认挂载点不是从/dev/sda开始的，直接使用cfdisk命令会报错：

cfdisk: cannot open /dev/sda: No such file or directory 
```

```
  所以用 fdisk -l 命令，查看自己硬盘挂载点

fdisk -l

Disk /dev/nvme0n1: 931.51 GiB, 1000204886016 bytes, 1953525168 sectors

```


​      比如我这里，查看自己硬盘挂载点为 /dev/nvme0n1 后，

      使用 cfdisk /dev/nvme0n1 进入下图分区工具界面 



（上下键控制上面的光标移动，左右键控制下面的光标移动）

光标上下移动至Free space，左右移至New，回车
大小自己选择1G或者默认不变
回车
光标移至Write，回车
输入yes，回车
光标左右移动至Write后回车，然后移动至Quit回车退出

Syncing disks.

**root@OpenWrt:~# mkfs.ext4 /dev/sda3**

mke2fs 1.45.6 (20-Mar-2020)

Creating filesystem with 1101056 4k blocks and 275264 inodes

Filesystem UUID: a686d37a-c77f-4a12-8e05-222ace47ae00

Superblock backups stored on blocks:

        32768, 98304, 163840, 229376, 294912, 819200, 884736

 







Allocating group tables: done

Writing inode tables: done

Creating journal (16384 blocks): done

Writing superblocks and filesystem accounting information: done

 

**root@OpenWrt:~# mount /dev/sda3 /mnt/sda3**

root@OpenWrt:~# **ls /mnt/sda3**

lost+found

root@OpenWrt:~# **cd /overlay**

root@OpenWrt:/overlay# **ls**

upper  work

root@OpenWrt:/overlay# **cd upper**

root@OpenWrt:/overlay/upper# **ls**

boot    etc     home    htdocs  lib     mnt     opt     root    run     usr     www

root@OpenWrt:/overlay/upper# **cd ..**

root@OpenWrt:/overlay# **cd ..**

**root@OpenWrt:/# cp -r /overlay/* /mnt/sda3**

root@OpenWrt:/# **ls /mnt/sda3**

**lost+found  upper       work**

简化方法

进入路由器后台，系统-挂载点
点“添加”
选中“启用此挂载点", 根据UUID指定你前面新建分区大小的UUID，挂载点为”作为外部overlay使用“，然后保存&应用
保存并应用后，重启你的设备，再打开网页，就可以看到软件包空间变大了







本文禁止转载或摘编 作者：吾爱探索 https://www.bilibili.com/read/cv9304632/ 出处：bilibili



 </details>



## iptables

<details>
  <summary>【查看详情】</summary>

# iptables

Linux上常用的防火墙软件

## 补充说明

**iptables命令** 是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。

- 补充说明
  - [语法](https://wangchujiang.com/linux-command/c/iptables.html#语法)
  - [选项](https://wangchujiang.com/linux-command/c/iptables.html#选项)
- 基本参数
  - [命令选项输入顺序](https://wangchujiang.com/linux-command/c/iptables.html#命令选项输入顺序)
  - [工作机制](https://wangchujiang.com/linux-command/c/iptables.html#工作机制)
  - [防火墙的策略](https://wangchujiang.com/linux-command/c/iptables.html#防火墙的策略)
  - [防火墙的策略](https://wangchujiang.com/linux-command/c/iptables.html#防火墙的策略-1)
  - 实例
    - [清空当前的所有规则和计数](https://wangchujiang.com/linux-command/c/iptables.html#清空当前的所有规则和计数)
    - [配置允许ssh端口连接](https://wangchujiang.com/linux-command/c/iptables.html#配置允许ssh端口连接)
    - [允许本地回环地址可以正常使用](https://wangchujiang.com/linux-command/c/iptables.html#允许本地回环地址可以正常使用)
    - [设置默认的规则](https://wangchujiang.com/linux-command/c/iptables.html#设置默认的规则)
    - [配置白名单](https://wangchujiang.com/linux-command/c/iptables.html#配置白名单)
    - [开启相应的服务端口](https://wangchujiang.com/linux-command/c/iptables.html#开启相应的服务端口)
    - [保存规则到配置文件中](https://wangchujiang.com/linux-command/c/iptables.html#保存规则到配置文件中)
    - [列出已设置的规则](https://wangchujiang.com/linux-command/c/iptables.html#列出已设置的规则)
    - [清除已有规则](https://wangchujiang.com/linux-command/c/iptables.html#清除已有规则)
    - [删除已添加的规则](https://wangchujiang.com/linux-command/c/iptables.html#删除已添加的规则)
    - [开放指定的端口](https://wangchujiang.com/linux-command/c/iptables.html#开放指定的端口)
    - [屏蔽IP](https://wangchujiang.com/linux-command/c/iptables.html#屏蔽ip)
    - [指定数据包出去的网络接口](https://wangchujiang.com/linux-command/c/iptables.html#指定数据包出去的网络接口)
    - [查看已添加的规则](https://wangchujiang.com/linux-command/c/iptables.html#查看已添加的规则)
    - [启动网络转发规则](https://wangchujiang.com/linux-command/c/iptables.html#启动网络转发规则)
    - [端口映射](https://wangchujiang.com/linux-command/c/iptables.html#端口映射)
    - [字符串匹配](https://wangchujiang.com/linux-command/c/iptables.html#字符串匹配)
    - [阻止Windows蠕虫的攻击](https://wangchujiang.com/linux-command/c/iptables.html#阻止windows蠕虫的攻击)
    - [防止SYN洪水攻击](https://wangchujiang.com/linux-command/c/iptables.html#防止syn洪水攻击)

### 语法

```shell
iptables(选项)(参数)
```

### 选项

```shell
-t, --table table 对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表。

# 通用匹配：源地址目标地址的匹配
-p：指定要匹配的数据包协议类型；
-s, --source [!] address[/mask] ：把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如：192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如：192.168.1.0/255.255.255.0。
-d, --destination [!] address[/mask] ：地址格式同上，但这里是指定地址为目的地址，按此进行过滤。
-i, --in-interface [!] <网络接口name> ：指定数据包的来自来自网络接口，比如最常见的 eth0 。注意：它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，"!" 表示取反。
-o, --out-interface [!] <网络接口name> ：指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。

# 查看管理命令
-L, --list [chain] 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则。

# 规则管理命令
-A, --append chain rule-specification 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定。
-I, --insert chain [rulenum] rule-specification 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号。
-D, --delete chain rule-specification -D, --delete chain rulenum 在指定的链 chain 中删除一个或多个指定规则。
-R num：Replays替换/修改第几条规则

# 链管理命令（这都是立即生效的）
-P, --policy chain target ：为指定的链 chain 设置策略 target。注意，只有内置的链才允许有策略，用户自定义的是不允许的。
-F, --flush [chain] 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则。
-N, --new-chain chain 用指定的名字创建一个新的链。
-X, --delete-chain [chain] ：删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链。
-E, --rename-chain old-chain new-chain ：用指定的新名字去重命名指定的链。这并不会对链内部造成任何影响。
-Z, --zero [chain] ：把指定链，或者表中的所有链上的所有计数器清零。

-j, --jump target <指定目标> ：即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链。
-h：显示帮助信息；
```

## 基本参数

| 参数        | 作用                                           |
| ----------- | ---------------------------------------------- |
| -P          | 设置默认策略:iptables -P INPUT (DROP           |
| -F          | 清空规则链                                     |
| -L          | 查看规则链                                     |
| -A          | 在规则链的末尾加入新规则                       |
| -I          | num 在规则链的头部加入新规则                   |
| -D          | num 删除某一条规则                             |
| -s          | 匹配来源地址IP/MASK，加叹号"!"表示除这个IP外。 |
| -d          | 匹配目标地址                                   |
| -i          | 网卡名称 匹配从这块网卡流入的数据              |
| -o          | 网卡名称 匹配从这块网卡流出的数据              |
| -p          | 匹配协议,如tcp,udp,icmp                        |
| --dport num | 匹配目标端口号                                 |
| --sport num | 匹配来源端口号                                 |

#### 命令选项输入顺序

```shell
iptables -t 表名 <-A/I/D/R> 规则链名 [规则号] <-i/o 网卡名> -p 协议名 <-s 源IP/源子网> --sport 源端口 <-d 目标IP/目标子网> --dport 目标端口 -j 动作
```

#### 工作机制

规则链名包括(也被称为五个钩子函数（hook functions）)：

- **INPUT链** ：处理输入数据包。
- **OUTPUT链** ：处理输出数据包。
- **FORWARD链** ：处理转发数据包。
- **PREROUTING链** ：用于目标地址转换（DNAT）。
- **POSTOUTING链** ：用于源地址转换（SNAT）。

#### 防火墙的策略

防火墙策略一般分为两种，一种叫`通`策略，一种叫`堵`策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，`所以通，是要全通，而堵，则是要选择`。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter过滤的功能，而定义地址转换的功能的则是nat选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。

我们现在用的比较多个功能有3个：

1. filter 定义允许或者不允许的，只能做在3个链上：INPUT ，FORWARD ，OUTPUT
2. nat 定义地址转换的，也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING
3. mangle功能:修改报文原数据，是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING

我们修改报文原数据就是来修改TTL的。能够实现将数据包的元数据拆开，在里面做标记/修改内容的。而防火墙标记，其实就是靠mangle来实现的。

小扩展:

- 对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT
- 对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING
- 而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING

iptables/netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们iptables现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。

iptables还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。

注意：规则的次序非常关键，`谁的规则越严格，应该放的越靠前`，而检查规则的时候，是按照从上往下的方式进行检查的。

表名包括：

- **raw** ：高级功能，如：网址过滤。
- **mangle** ：数据包修改（QOS），用于实现服务质量。
- **nat** ：地址转换，用于网关路由器。
- **filter** ：包过滤，用于防火墙规则。

动作包括：

- **ACCEPT** ：接收数据包。
- **DROP** ：丢弃数据包。
- **REDIRECT** ：重定向、映射、透明代理。
- **SNAT** ：源地址转换。
- **DNAT** ：目标地址转换。
- **MASQUERADE** ：IP伪装（NAT），用于ADSL。
- **LOG** ：日志记录。
- **SEMARK** : 添加SEMARK标记以供网域内强制访问控制（MAC）

```shell
                             ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓
 ┌───────────────┐           ┃    Network    ┃
 │ table: filter │           ┗━━━━━━━┳━━━━━━━┛
 │ chain: INPUT  │◀────┐             │
 └───────┬───────┘     │             ▼
         │             │   ┌───────────────────┐
  ┌      ▼      ┐      │   │ table: nat        │
  │local process│      │   │ chain: PREROUTING │
  └             ┘      │   └─────────┬─────────┘
         │             │             │
         ▼             │             ▼              ┌─────────────────┐
┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅    │     ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅      │table: nat       │
 Routing decision      └───── outing decision ─────▶│chain: PREROUTING│
┅┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅┅          ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅      └────────┬────────┘
         │                                                   │
         ▼                                                   │
 ┌───────────────┐                                           │
 │ table: nat    │           ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅               │
 │ chain: OUTPUT │    ┌─────▶ outing decision ◀──────────────┘
 └───────┬───────┘    │      ┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅
         │            │              │
         ▼            │              ▼
 ┌───────────────┐    │   ┌────────────────────┐
 │ table: filter │    │   │ chain: POSTROUTING │
 │ chain: OUTPUT ├────┘   └──────────┬─────────┘
 └───────────────┘                   │
                                     ▼
                             ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓
                             ┃    Network    ┃
                             ┗━━━━━━━━━━━━━━━┛
```

### 实例

#### 清空当前的所有规则和计数

```shell
iptables -F  # 清空所有的防火墙规则
iptables -X  # 删除用户自定义的空链
iptables -Z  # 清空计数
```

#### 配置允许ssh端口连接

```shell
iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT
# 22为你的ssh端口， -s 192.168.1.0/24表示允许这个网段的机器来连接，其它网段的ip地址是登陆不了你的机器的。 -j ACCEPT表示接受这样的请求
```

#### 允许本地回环地址可以正常使用

```shell
iptables -A INPUT -i lo -j ACCEPT
#本地圆环地址就是那个127.0.0.1，是本机上使用的,它进与出都设置为允许
iptables -A OUTPUT -o lo -j ACCEPT
```

#### 设置默认的规则

```shell
iptables -P INPUT DROP # 配置默认的不让进
iptables -P FORWARD DROP # 默认的不允许转发
iptables -P OUTPUT ACCEPT # 默认的可以出去
```

#### 配置白名单

```shell
iptables -A INPUT -p all -s 192.168.1.0/24 -j ACCEPT  # 允许机房内网机器可以访问
iptables -A INPUT -p all -s 192.168.140.0/24 -j ACCEPT  # 允许机房内网机器可以访问
iptables -A INPUT -p tcp -s 183.121.3.7 --dport 3380 -j ACCEPT # 允许183.121.3.7访问本机的3380端口
```

#### 开启相应的服务端口

```shell
iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开启80端口，因为web对外都是这个端口
iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT # 允许被ping
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 已经建立的连接得让它进来
```

#### 保存规则到配置文件中

```shell
cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak # 任何改动之前先备份，请保持这一优秀的习惯
iptables-save > /etc/sysconfig/iptables
cat /etc/sysconfig/iptables
```

#### 列出已设置的规则

> iptables -L [-t 表名] [链名]

- 四个表名 `raw`，`nat`，`filter`，`mangle`
- 五个规则链名 `INPUT`、`OUTPUT`、`FORWARD`、`PREROUTING`、`POSTROUTING`
- filter表包含`INPUT`、`OUTPUT`、`FORWARD`三个规则链

```shell
iptables -L -t nat                  # 列出 nat 上面的所有规则
#            ^ -t 参数指定，必须是 raw， nat，filter，mangle 中的一个
iptables -L -t nat  --line-numbers  # 规则带编号
iptables -L INPUT

iptables -L -nv  # 查看，这个列表看起来更详细
```

#### 清除已有规则

```shell
iptables -F INPUT  # 清空指定链 INPUT 上面的所有规则
iptables -X INPUT  # 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。
                   # 如果没有指定链名，则会删除该表中所有非内置的链。
iptables -Z INPUT  # 把指定链，或者表中的所有链上的所有计数器清零。
```

#### 删除已添加的规则

```shell
# 添加一条规则
iptables -A INPUT -s 192.168.1.5 -j DROP
```

将所有iptables以序号标记显示，执行：

```shell
iptables -L -n --line-numbers
```

比如要删除INPUT里序号为8的规则，执行：

```shell
iptables -D INPUT 8
```

#### 开放指定的端口

```shell
iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               #允许本地回环接口(即运行本机访问本机)
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    #允许已建立的或相关连的通行
iptables -A OUTPUT -j ACCEPT         #允许所有本机向外的访问
iptables -A INPUT -p tcp --dport 22 -j ACCEPT    #允许访问22端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT    #允许访问80端口
iptables -A INPUT -p tcp --dport 21 -j ACCEPT    #允许ftp服务的21端口
iptables -A INPUT -p tcp --dport 20 -j ACCEPT    #允许FTP服务的20端口
iptables -A INPUT -j reject       #禁止其他未允许的规则访问
iptables -A FORWARD -j REJECT     #禁止其他未允许的规则访问
```

#### 屏蔽IP

```shell
iptables -A INPUT -p tcp -m tcp -s 192.168.0.8 -j DROP  # 屏蔽恶意主机（比如，192.168.0.8
iptables -I INPUT -s 123.45.6.7 -j DROP       #屏蔽单个IP的命令
iptables -I INPUT -s 123.0.0.0/8 -j DROP      #封整个段即从123.0.0.1到123.255.255.254的命令
iptables -I INPUT -s 124.45.0.0/16 -j DROP    #封IP段即从123.45.0.1到123.45.255.254的命令
iptables -I INPUT -s 123.45.6.0/24 -j DROP    #封IP段即从123.45.6.1到123.45.6.254的命令是
```

#### 指定数据包出去的网络接口

只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。

```shell
iptables -A FORWARD -o eth0
```

#### 查看已添加的规则

```shell
iptables -L -n -v
Chain INPUT (policy DROP 48106 packets, 2690K bytes)
 pkts bytes target     prot opt in     out     source               destination
 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0
 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22
1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80
4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED
 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)
 pkts bytes target     prot opt in     out     source               destination
 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0
```

#### 启动网络转发规则

公网`210.14.67.7`让内网`192.168.188.0/24`上网

```shell
iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to-source 210.14.67.127
```

#### 端口映射

本机的 2222 端口映射到内网 虚拟机的22 端口

```shell
iptables -t nat -A PREROUTING -d 210.14.67.127 -p tcp --dport 2222  -j DNAT --to-dest 192.168.188.115:22
```

#### 字符串匹配

比如，我们要过滤所有TCP连接中的字符串`test`，一旦出现它我们就终止这个连接，我们可以这么做：

```shell
iptables -A INPUT -p tcp -m string --algo kmp --string "test" -j REJECT --reject-with tcp-reset
iptables -L

# Chain INPUT (policy ACCEPT)
# target     prot opt source               destination
# REJECT     tcp  --  anywhere             anywhere            STRING match "test" ALGO name kmp TO 65535 reject-with tcp-reset
#
# Chain FORWARD (policy ACCEPT)
# target     prot opt source               destination
#
# Chain OUTPUT (policy ACCEPT)
# target     prot opt source               destination
```

#### 阻止Windows蠕虫的攻击

```shell
iptables -I INPUT -j DROP -p tcp -s 0.0.0.0/0 -m string --algo kmp --string "cmd.exe"
```

#### 防止SYN洪水攻击

```shell
iptables -A INPUT -p tcp --syn -m limit --limit 5/second -j ACCEPT
```

#### 添加SECMARK记录

```shell
iptables -t mangle -A INPUT -p tcp --src 192.168.1.2 --dport 443 -j SECMARK --selctx system_u:object_r:myauth_packet_t
# 向从 192.168.1.2:443 以TCP方式发出到本机的包添加MAC安全上下文 system_u:object_r:myauth_packet_t
```

## 更多实例

> 用iptables搭建一套强大的安全防护盾 http://www.imooc.com/learn/389

iptables: linux 下应用层防火墙工具

iptables 5链: 对应 Hook point netfilter: linux 操作系统核心层内部的一个数据包处理模块 Hook point: 数据包在 netfilter 中的挂载点; `PRE_ROUTING / INPUT / OUTPUT / FORWARD / POST_ROUTING`

iptables & netfilter ![img](http://7xq89b.com1.z0.glb.clouddn.com/netfilter&iptables.jpg)

iptables 4表5链 ![img](http://7xq89b.com1.z0.glb.clouddn.com/iptables-data-stream.jpg)

iptables rules ![img](http://7xq89b.com1.z0.glb.clouddn.com/iptables-rules.jpg)

- 4表

**filter**: 访问控制 / 规则匹配 **nat**: 地址转发 mangle / raw

- 规则

数据访问控制: ACCEPT / DROP / REJECT 数据包改写(nat -> 地址转换): snat / dnat 信息记录: log

## 使用场景实例

- 场景一

开放 tcp 10-22/80 端口 开放 icmp 其他未被允许的端口禁止访问

存在的问题: 本机无法访问本机; 本机无法访问其他主机

- 场景二

ftp: 默认被动模式(服务器产生随机端口告诉客户端, 客户端主动连接这个端口拉取数据) vsftpd: 使 ftp 支持主动模式(客户端产生随机端口通知服务器, 服务器主动连接这个端口发送数据)

- 场景三

允许外网访问: web http -> 80/tcp; https -> 443/tcp mail smtp -> 25/tcp; smtps -> 465/tcp pop3 -> 110/tcp; pop3s -> 995/tcp imap -> 143/tcp

内部使用: file nfs -> 123/udp samba -> 137/138/139/445/tcp ftp -> 20/21/tcp remote ssh -> 22/tcp sql mysql -> 3306/tcp oracle -> 1521/tcp

- 场景四

nat 转发

- 场景五

防CC攻击

```shell
iptables -L -F -A -D # list flush append delete
# 场景一
iptables -I INPUT -p tcp --dport 80 -j ACCEPT # 允许 tcp 80 端口
iptables -I INPUT -p tcp --dport 10:22 -j ACCEPT # 允许 tcp 10-22 端口
iptables -I INPUT -p icmp -j ACCEPT # 允许 icmp
iptables -A INPUT -j REJECT # 添加一条规则, 不允许所有

# 优化场景一
iptables -I INPUT -i lo -j ACCEPT # 允许本机访问
iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 允许访问外网
iptables -I INPUT -p tcp --dport 80 -s 10.10.188.233 -j ACCEPT # 只允许固定ip访问80

# 场景二
vi /etc/vsftpd/vsftpd.conf # 使用 vsftpd 开启 ftp 主动模式
port_enable=yes
connect_from_port_20=YES
iptables -I INPUT -p tcp --dport 21 -j ACCEPT

vi /etc/vsftpd/vsftpd.conf # 建议使用 ftp 被动模式
pasv_min_port=50000
pasv_max_port=60000
iptables -I INPUT -p tcp --dport 21 -j ACCEPT
iptables -I INPUT -p tcp --dport 50000:60000 -j ACCEPT

# 还可以使用 iptables 模块追踪来自动开发对应的端口

# 场景三
iptables -I INPUT -i lo -j ACCEPT # 允许本机访问
iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 允许访问外网
iptables -I INPUT -s 10.10.155.0/24 -j ACCEPT # 允许内网访问
iptables -I INPUT -p tcp -m multiport --dports 80,1723 -j ACCEPT # 允许端口, 80 -> http, 1723 -> vpn
iptables -A INPUT -j REJECT # 添加一条规则, 不允许所有

iptables-save # 保存设置到配置文件

# 场景四
iptables -t nat -L # 查看 nat 配置

iptables -t nat -A POST_ROUTING -s 10.10.177.0/24 -j SNAT --to 10.10.188.232 # SNAT
vi /etc/sysconfig/network # 配置网关

iptables -t nat -A POST_ROUTING -d 10.10.188.232 -p tcp --dport 80 -j DNAT --to 10.10.177.232:80 # DNAT

#场景五
iptables -I INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 100 -j REJECT # 限制并发连接访问数
iptables -I INPUT -m limit --limit 3/hour --limit-burst 10 -j ACCEPT # limit模块; --limit-burst 默认为5
```



 </details>



## 编译OpenWrt

<details>
  <summary>【查看详情】</summary>

Lean OpenWrt编译

\1. 不要用 root 用户进行编译

\2. 国内用户编译前最好准备好梯子

\3. 默认登陆IP 192.168.1.1 密码 password

编译命令

\1. 首先装好 Linux 系统，推荐 Debian 11 或 Ubuntu LTS

\2. 安装编译依赖

```
   sudo apt update -y
   sudo apt full-upgrade -y
   sudo apt install -y ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
   bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext gcc-multilib g++-multilib \
   git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libfuse-dev libglib2.0-dev libgmp3-dev \
   libltdl-dev libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libpython3-dev libreadline-dev \
   libssl-dev libtool lrzsz mkisofs msmtp ninja-build p7zip p7zip-full patch pkgconf python2.7 python3 \
   python3-pyelftools python3-setuptools qemu-utils rsync scons squashfs-tools subversion swig texinfo \
   uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev
```

\3. 下载源代码，更新 feeds 并选择配置

```
   git clone https://github.com/coolsnowwolf/lede
   cd lede
   ./scripts/feeds update -a
   ./scripts/feeds install -a
   make menuconfig
```



```
git clone https://github.com/openwrt/openwrt        **官方版本**
git clone https://github.com/coolsnowwolf/lede       **lede版本**
git clone -b 22.03 --single-branch https://github.com/Lienol/openwrt   **lienol版本**
cd openwrt            **切换到文件目录**
```



\4. 下载 dl 库，编译固件 （-j 后面是线程数，第一次编译推荐用单线程）

```
   make download -j8
   make V=s -j1
```

本套代码保证肯定可以编译成功。里面包括了 R23 所有源代码，包括 IPK 的。 你可以自由使用，但源码编译二次发布请注明我的 GitHub 仓库链接。谢谢合作！ 二次编译：

```
cd lede
git pull
./scripts/feeds update -a
./scripts/feeds install -a
make defconfig
make download -j8
make V=s -j$(nproc)
```



如果需要重新配置：

```
rm -rf .config
make menuconfig
make V=s -j$(nproc)



rm -rf ./tmp && rm -rf .config
make menuconfig
make V=s -j$(nproc)

编译完成后输出路径：bin/targets
```

如果编译失败，可以执行以下命令：

make clean 删除编译目录/bin和/build_dir目录中的文件

make dirclean 除了删除编译目录之外还删除编译工具目录，删除/bin和/build_dir目录的中的文件(make clean)以及/staging_dir、/toolchain、/tmp和/logs中的文件，一般在更换CPU架构的情况下才操作。



下载编译压缩包

编译完成后输出路径：home/用户名/openwrt/bin/targets，下载到本地电脑，需要通过SSH远程登录进行下载。ubuntu默认是没开通SSH登录，所以我们需要进行开通。

```
开通SSH登录方法：

1，必须切换成为root用户
sudo -i
2，先更新软件列表和更新软件
sudo apt-get update
3，先更新软件列表和更新软件
sudo apt-get upgrade
4，安装ssh
apt-get install ssh
5，启动ssh服务
sudo /etc/init.d/ssh start
6，检查是否有ssh环境
ps -e | grep ssh




ubuntu开通root登录SSH权限

1， 使用普通用户登录后切换root
sudo -i
2，创建root管理员密码
passwd root
3，开启root登录
sudo sed -i 's/^#?PermitRootLogin./PermitRootLogin yes/g' /etc/ssh/sshd_config
4，开启密码验证
sudo sed -i 's/^#?PasswordAuthentication./PasswordAuthentication yes/g' /etc/ssh/sshd_config
5，重启ssh服务
service sshd restart
6，检查是否有ssh环境
ps -e | grep ssh


```



安装Nginx

首先，您需要在OpenWrt上安装Nginx。可以使用以下命令在终端中进行安装：

```

opkg update
opkg install nginx
```

安装Nginx后，您可以通过以下命令启动和停止它：

```

/etc/init.d/nginx start    # 启动Nginx
/etc/init.d/nginx stop     # 停止Nginx
```

配置Nginx

接下来，您需要在OpenWrt上配置Nginx。Nginx的配置文件位于 /etc/nginx/nginx.conf 中。您可以通过修改此文件来配置Nginx。

例如，要将Nginx配置为监听端口80并向所有请求发送欢迎消息，请按照以下步骤操作：

1. 使用文本编辑器打开 /etc/nginx/nginx.conf 文件：

```

vi /etc/nginx/nginx.conf
```

1. 在 http 块中添加以下内容：

```
worker_processes auto;

user root;

events {}

http {

upstream alist {
  server 127.0.0.1:5244;
}



server {
        listen       15244;
        server_name   localhost;
        location / {
           proxy_pass http://alist;
           proxy_set_header HOST $host;
           proxy_set_header X-Forwarded-Proto $scheme;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
      
    }

}

```

1. 保存并关闭文件。
2. 重新启动Nginx以使更改生效：

```

/etc/init.d/nginx restart
```

使用Nginx模块

要在OpenWrt上使用Nginx模块，您需要将相应的模块安装到Nginx中。这些模块可以使用以下命令安装：

```

opkg update
opkg install nginx-mod-<module_name>
```

其中 <module_name> 是要安装的模块的名称。例如，要安装HttpEchoModule，可以使用以下命令：

```

opkg update
opkg install nginx-mod-http-echo
```

安装完毕后，您需要修改 /etc/nginx/nginx.conf 文件





 </details>





## x-ui docker image

<details>
  <summary>【查看详情】</summary>

# x-ui docker image



[![Docker Pulls](https://camo.githubusercontent.com/d96851e7ecb70b37627c8ee4c37ace32b44849b96cfd3c21d165ee195b16c80c/68747470733a2f2f696d672e736869656c64732e696f2f646f636b65722f70756c6c732f656e77616961782f782d75692e7376673f7374796c653d666c61742d737175617265)](https://hub.docker.com/r/enwaiax/x-ui) [![Contributors](https://camo.githubusercontent.com/34db02d30a62844e8ddd0a7a66be59f3cf0cf4e9e214798ca3af61be5dbef25e/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f636f6e7472696275746f72732f63686173696e6736362f782d75692e7376673f7374796c653d666c61742d737175617265)](https://github.com/Chasing66/x-ui/graphs/contributors) [![Forks](https://camo.githubusercontent.com/fca4b77a86a23f5579544684557354e2faae40118e31e6bb939d46de40f707e2/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f666f726b732f63686173696e6736362f782d75692e7376673f7374796c653d666c61742d737175617265)](https://github.com/Chasing66/x-ui/network/members) [![Stargazers](https://camo.githubusercontent.com/95b070f9bfcd5913c3f0e934820f4e70db4da2dedc77ce793bc7d492b59b1907/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f73746172732f63686173696e6736362f782d75692e7376673f7374796c653d666c61742d737175617265)](https://github.com/Chasing66/x-ui/stargazers) [![Issues](https://camo.githubusercontent.com/53896d0afa3d78e3eb73548ba7453d36b786254823e2a2a87d21fb8df5c2e224/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6973737565732f63686173696e6736362f782d75692e7376673f7374796c653d666c61742d737175617265)](https://github.com/Chasing66/x-ui/issues) [![MIT License](https://camo.githubusercontent.com/eaa9f26d39a11e4c60209a4d9de91a64470a37c667e17ea2662b43de08495f5c/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f43686173696e6736362f782d75692e7376673f7374796c653d666c61742d737175617265)](https://github.com/Chasing66/x-ui/blob/main/LICENSE)

> x-ui docker 版本

可以通过使用不同的`tag`来使用不同作者的镜像

Tagamd64arm64armv7s390x[vaxilu/x-ui](https://github.com/vaxilu/x-ui)latest✅✅✅✅[FranzKafkaYu/x-ui](https://github.com/FranzKafkaYu/x-ui)alpha-zh✅✅❌✅[X-UI-Unofficial/x-ui](https://github.com/X-UI-Unofficial)beta✅✅❌✅

### 为什么要使用`docker`



- 一致性且能保证环境隔离
- 快速部署
- 保证灵活性和扩展性
- 更好的可移植性
- 低成本
- 方便控制版本
- 安全
- .....

### 对于 x-ui，如果使用 docker



- 无需关心原宿主机的系统，架构，版本
- 不会破坏原系统，如果不想使用，很方便就能完全干净的卸载
- 部署方便且容易升级

### 如何使用



#### 前提：安装好 docker



使用官方一键脚本

```
curl -sSL https://get.docker.com/ | sh
```



#### 运行你的容器



##### 使用 [vaxilu/x-ui](https://github.com/vaxilu/x-ui) 版本的



```
mkdir x-ui && cd x-ui
docker run -itd --network=host \
    -v $PWD/db/:/etc/x-ui/ \
    -v $PWD/cert/:/root/cert/ \
    --name x-ui --restart=unless-stopped \
    enwaiax/x-ui
```



注意: 如果希望使用[FranzKafkaYu/x-ui](https://github.com/FranzKafkaYu/x-ui)版本，仅需要讲上述镜像修改为 `enwaiax/x-ui:alpha-zh`

##### 使用 docker-compose 运行



```
mkdir x-ui && cd x-ui
wget https://raw.githubusercontent.com//chasing66/x-ui/main/docker-compose.yml
docker compose up -d
```



#### 如何启用 ssl



- 假设你的 x-ui 端口是 `54321`
- 假设你的 IP 是 `10.10.10.10`
- 假设你的域名是 `xui.example.com`，且已经做好 A 记录解析
- 假设你使用的是 Debian 10+或者 Ubuntu 18+的系统
- 假设你的邮箱是 `xxxx@example.com`

##### 步骤如下



1. 安装必要软件

```
sudo apt update
sudo apt install snapd nginx
sudo snap install core
sudo snap refresh core
sudo snap install --classic certbot
sudo ln -s /snap/bin/certbot /usr/bin/certbot
```



1. 新建一个 nginx 配置

```
touch /etc/nginx/conf.d/xui.conf
```



增加以下配置，按照实际情况调整

```
server {
    listen 80;
    listen [::]:80;
    server_name xui.example.com;

    location / {
        proxy_redirect off;
        proxy_pass http://127.0.0.1:54321;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
    }

    # 反代websocket
     location /xray {
         proxy_redirect off;
         proxy_pass http://127.0.0.1:10001;
         proxy_http_version 1.1;
         proxy_set_header Upgrade $http_upgrade;
         proxy_set_header Connection "upgrade";
         proxy_set_header X-Real-IP $remote_addr;
         proxy_set_header Host $http_host;
         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
         proxy_set_header Y-Real-IP $realip_remote_addr;
     }
}
```



1. 检查配置是否正常

```
nginx -t
```



1. 申请证书，按照提示设置

```
certbot --nginx --agree-tos --no-eff-email --email xxxxx@example.com
```



更多细节可以参考 [cerbot](https://certbot.eff.org/)

1. 刷新 nginx 配置生效

```
ngins -s reload
```



1. 配置定时任务

```
sudo certbot renew --dry-run
```





### 3X-UI

[English⁠](https://github.com/aircross/3x-ui/blob/main/README.en.md) | [Español⁠](https://github.com/aircross/3x-ui/blob/main/README.es_ES.md) | [Русский⁠](https://github.com/aircross/3x-ui/blob/main/README.ru_RU.md)

**一个更好的面板 • 基于Xray Core构建**

[![img](https://img.shields.io/github/v/release/aircross/3x-ui.svg)](https://github.com/aircross/3x-ui/releases)[![img](https://img.shields.io/github/actions/workflow/status/aircross/3x-ui/release.yml.svg)](https://hub.docker.com/r/aircross/3x-ui)[![GO Version](https://img.shields.io/github/go-mod/go-version/aircross/3x-ui.svg)](https://hub.docker.com/r/aircross/3x-ui)[![Docker Pulls](https://img.shields.io/docker/pulls/aircross/3x-ui.svg?style=flat-square)](https://img.shields.io/docker/pulls/aircross/3x-ui.svg?style=flat-square)[![License](https://img.shields.io/badge/license-GPL%20V3-blue.svg?longCache=true)](https://www.gnu.org/licenses/gpl-3.0.en.html)

> **Disclaimer:** 此项目仅供个人学习交流，请不要用于非法目的，请不要在生产环境中使用。

**如果此项目对你有用，请给一个**:star2:

#### 默认信息

访问端口：2053

用户名/密码：admin

#### X-UI

如果你需要使用X-UI，可以点击这里访问：[aircross/x-ui⁠](https://github.com/aircross/x-ui)
[![Docker Pulls](https://img.shields.io/docker/pulls/aircross/x-ui.svg?style=flat-square)](https://img.shields.io/docker/pulls/aircross/x-ui.svg?style=flat-square)

#### 安装 & 升级

#### 通过Docker安装

**使用**

1. 安装Docker：

```shell
#国外服务器使用以下命令安装Docker
curl -fsSL https://get.docker.com | sh
# 设置开机自启
sudo systemctl enable docker.service
# 根据实际需要保留参数start|restart|stop
sudo service docker start|restart|stop
```

国内的请参照下面这个教程安装，需要配合能访问download.docker.com的服务器服用

**[和谐之后如何在国内安装Docker及拉取镜像使用⁠⁠](https://vps.la/2024/07/01/和谐之后如何在国内安装docker及拉取镜像使用/)**

1. docker compose安装，克隆仓库：

   ```sh
   git clone https://github.com/aircross/3x-ui.git
   cd 3x-ui
   ```

运行服务：

```sh
docker compose up -d
```

1. docker一键安装：

   ```sh
   mkdir -p /opt/docker/3x-ui/
   mkdir -p /opt/docker/acme.sh/
   docker run -itd \
      -e XRAY_VMESS_AEAD_FORCED=false \
      -v /opt/docker/3x-ui/:/etc/x-ui/ \
      -v /opt/docker/acme.sh/:/root/cert/ \
      --network=host \
      --restart=unless-stopped \
      --name 3x-ui \
      aircross/3x-ui:latest
   ```

##### 如果你需要安装ACME.SH用户管理SSL证书的Docker，可以执行一下命令

```bash
mkdir -p /opt/docker/acme.sh
docker run -itd -v /opt/docker/acme.sh:/acme.sh --net=host --restart=unless-stopped --name=acme.sh -v /var/run/docker.sock:/var/run/docker.sock neilpang/acme.sh daemon
docker exec \
    -e CF_Email=你的CF邮箱 \
    -e CF_Key=你的CF API Key  \
    acme.sh --issue -d demo.com  --dns dns_cf  \
    --server letsencrypt
#默认使用letsencrypt作废证书签发服务
```

x-ui的Docker执行命令添加下面这一行

```bash
    -v /opt/docker/acme.sh:/acme.sh/ \
    #在x-ui的docker里面域名证书的路径为/acme.sh/
```

更新至最新版本

```sh
 cd 3x-ui
 docker compose down
 docker compose pull 3x-ui
 docker compose up -d
```

从Docker中删除3x-ui

```sh
 docker stop 3x-ui
 docker rm 3x-ui
 cd --
 rm -r 3x-ui
bash <(curl -Ls https://raw.githubusercontent.com/aircross/3x-ui/master/install.sh)
```

#### Install Custom Version

To install your desired version, add the version to the end of the installation command. e.g., ver `v2.4.2`:

```bash
bash <(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh) v2.4.2
```



 </details>







## 零基础保姆级小白节点搭建教学，目前最安全最稳定的搭建方式，通过x-ui面板实现单端口多用户合租

<details>
  <summary>【查看详情】</summary>

### VPS购买

搬瓦工：[https://bwg.bulianglin.com](https://bwg.bulianglin.com/)

优惠码： **BWHCGLUKKB**

> 执行unminimize之后，中途如果出现如下图的A new version提示信息，输入数字2，再回车即可

![img](https://telegra.ph/file/8785b3996bd9aae003a67.png)

输入数字2，再回车



### 域名购买

namesilo：[https://name.bulianglin.com](https://name.bulianglin.com/)

优惠码：oldtong

### SSH工具

FinalShell：https://www.hostbuf.com/t/988.html

### 节点搭建

```
#更新软件源
apt update
#启用 BBR TCP 拥塞控制算法
echo "net.core.default_qdisc=fq" >> /etc/sysctl.conf
echo "net.ipv4.tcp_congestion_control=bbr" >> /etc/sysctl.conf
sysctl -p

#安装x-ui：
bash <(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh)

#安装nginx
apt install nginx
#安装acme：
curl https://get.acme.sh | sh
#添加软链接：
ln -s  /root/.acme.sh/acme.sh /usr/local/bin/acme.sh
#切换CA机构： 
acme.sh --set-default-ca --server letsencrypt
#申请证书： 
acme.sh  --issue -d 你的域名 -k ec-256 --webroot  /var/www/html
#安装证书：
acme.sh --install-cert -d 你的域名 --ecc --key-file /etc/x-ui/server.key  --fullchain-file /etc/x-ui/server.crt --reloadcmd "systemctl force-reload nginx"
```

### 寻找适合的伪装站

> http站点优先，个人网盘符合单节点大流量特征

示例关键字：intext:登录 Cloudreve

### 配置nginx

配置文件路径：/etc/nginx/nginx.conf

```
user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 1024;
}

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    gzip on;

    server {
        listen 443 ssl;
        
        server_name nicename.co;  #你的域名
        ssl_certificate       /etc/x-ui/server.crt;  #证书位置
        ssl_certificate_key   /etc/x-ui/server.key; #私钥位置
        
        ssl_session_timeout 1d;
        ssl_session_cache shared:MozSSL:10m;
        ssl_session_tickets off;
        ssl_protocols    TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers off;

        location / {
            proxy_pass https://bing.com; #伪装网址
            proxy_redirect off;
            proxy_ssl_server_name on;
            sub_filter_once off;
            sub_filter "bing.com" $server_name;
            proxy_set_header Host "bing.com";
            proxy_set_header Referer $http_referer;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto https;
            proxy_set_header Accept-Encoding "";
            proxy_set_header Accept-Language "zh-CN";
        }


        location /ray {   #分流路径
            proxy_redirect off;
            proxy_pass http://127.0.0.1:10000; #Xray端口
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
        
        location /xui {   #xui路径
            proxy_redirect off;
            proxy_pass http://127.0.0.1:9999;  #xui监听端口
            proxy_http_version 1.1;
            proxy_set_header Host $host;
        }
    }

    server {
        listen 80;
        location /.well-known/ {
               root /var/www/html;
            }
        location / {
                rewrite ^(.*)$ https://$host$1 permanent;
            }
    }
}
```

> 每次修改nginx配置文件后必须使用 systemctl reload nginx 命令重新加载配置文件

### 多用户合租

> 通过修改nginx的配置文件实现ws path路径分流

```
location /ray {   #分流路径
    proxy_redirect off;
    proxy_pass http://127.0.0.1:10000; #Xray端口
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
```



 </details>



## docker离线镜像

<details>
  <summary>【查看详情】</summary>

```
name: Alist_docker_amd64
on:
  workflow_dispatch:
    inputs:
      docker_images:
        description: '请填写docker镜像名称 多个用英文逗号分开'
        required: true
        default: 'xhofe/alist:latest'  # 设置默认的 Docker 镜像列表

jobs:
  pull_and_package:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Clean up Docker to free space
      run: |
          docker system prune -a -f
          docker volume prune -f

    - name: Pull Docker Images and Package
      run: |
        images="${{ github.event.inputs.docker_images }}"
        IFS=',' read -r -a image_array <<< "$images"
        for image in "${image_array[@]}"; do
          docker pull "${image}" --platform "linux/amd64"
          docker save "${image}" -o "$(echo "${image}" | sed 's/[\/:]/-/g')-amd64.tar"
        done

    - name: Generate MD5 checksums
      run: |
          for file in *.tar; do
            md5sum "$file" >> "${file}.md5"
          done 
          
    - name: Get filenames in current directory
      run: |
       echo "FILENAMES=$(ls *.tar 2>/dev/null | tr '\n' ' ' | sed 's/ $//')" >> $GITHUB_ENV    
   
    - name: Compress each TAR file separately
      run: |
        for file in *.tar; do
          tar -czf "${file}.gz" "$file" "${file}.md5"
        done
      
    - name: Set Release Date
      id: set_date
      run: echo "RELEASE_DATE=$(date +'%Y-%m-%d')" >> $GITHUB_ENV



    - name: Prepare MD5 content
      id: prepare_md5
      run: |
          echo "MD5_CONTENTS<<EOF" >> $GITHUB_ENV
          cat *-amd64.tar.md5 >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: dockerimages
        path: '*.gz'
        retention-days: 1  # 将保留天数设置为 1 天
    - name: Create release
      id: create_release
      uses: ncipollo/release-action@v1
      with:
        tag: "release-${{ env.RELEASE_DATE }}-${{ github.run_id }}"
        name: "${{ env.RELEASE_DATE }}: ${{ env.FILENAMES }}"
        body: ${{ env.MD5_CONTENTS }}
        artifacts: |
                   *.tar
                   *.md5
                   *.gz
                

    - name: Clean up intermediate files
      run: |
        rm *-amd64.tar

```

 </details>
