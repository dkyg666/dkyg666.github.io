import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,e as t,a,o as i,r as s}from"./app-BA4_Sfsq.js";const p={};function c(m,e){const n=s("Catalog");return i(),o("div",null,[e[0]||(e[0]=t('<h1 id="底层实现" tabindex="-1"><a class="header-anchor" href="#底层实现"><span>底层实现</span></a></h1><p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p><p>我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。<br> 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。<br> 例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</p><p>我们知道，在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU 等等，所有的资源都是应用进程直接共享的。<br> 要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。<br> 前者相对容易实现一些，后者则需要宿主机系统的深入支持。</p><p>随着 Linux 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。这种机制就是容器（Container），利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。</p>',5)),a(n)])}const u=r(p,[["render",c],["__file","index.html.vue"]]),f=JSON.parse('{"path":"/index/Docker/underly/","title":"底层实现","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"createdTime":1731129855000,"updatedTime":1731129855000,"contributors":[{"name":"dkyg666","email":"43946866+dkyg666@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":1.5,"words":451},"filePathRelative":"index/Docker/underly/README.md","localizedDate":"2024年11月9日","excerpt":"\\n<p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p>\\n<p>我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。<br>\\n这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。<br>\\n例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</p>"}');export{u as comp,f as data};
